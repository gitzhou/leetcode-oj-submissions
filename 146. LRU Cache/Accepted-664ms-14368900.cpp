// 
// Generated by FetchLeetcodeSubmission Project on GitCafe.
// Visit https://gitcafe.com/aaronzhou/FetchLeetcodeSubmission for more information.
// Contact Me: aaron67[AT]aaron67.cc
// 
// 146. LRU Cache
// https://leetcode.com/problems/lru-cache/
// 

class LRUCache{
public:
    LRUCache(int capacity) {
        m_capacity = capacity;
    }
    
    int get(int key) {
        if (m_dic.count(key) == 1) { // key存在
            int value = m_dic[key]->second; // 取对应的value
            m_cache.erase(m_dic[key]); // 在cache-list中删掉元素
            m_cache.push_front(make_pair(key, value)); // 在cache-list头插入元素
            m_dic[key] = m_cache.begin(); // 更新map对象
            return value;
        }
        return -1;
    }
    
    void set(int key, int value) {
        if (m_dic.count(key) == 1) { // key存在
            m_cache.erase(m_dic[key]); // 在cache-list中删掉元素
        } else if (m_cache.size() == m_capacity) { // key不存在且cache-list已满
            int k = (--m_cache.end())->first; // 取要删除的key
            m_cache.pop_back(); // 删除cache-list最后一个元素
            m_dic.erase(k); // 更新map对象
        }
        m_cache.push_front(make_pair(key, value)); // 在cache-list头插入元素
        m_dic[key] = m_cache.begin(); // 更新map对象
    }
    
private:
    int m_capacity;
    map<int, list<pair<int, int> >::iterator> m_dic;
    list<pair<int, int> > m_cache;
};

// 
// Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and set. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. set(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item. Subscribe to see which companies asked this question Show Tags Design
// 
