// 
// Generated by FetchLeetcodeSubmission Project on GitCafe.
// Visit https://gitcafe.com/aaronzhou/FetchLeetcodeSubmission for more information.
// Contact Me: aaron67[AT]aaron67.cc
// 
// Construct Binary Tree from Inorder and Postorder Traversal
// https://oj.leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/
// 

/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode *buildTree(vector<int> &inorder, vector<int> &postorder) {
        return build(inorder, 0, inorder.size(), postorder, 0, postorder.size());
    }
    
private:
    // inorder[inorderi, inorderj)
    // postorder[postorderi, postorderj)
    TreeNode *build(const vector<int> &inorder, size_t inorderi, size_t inorderj,
                    const vector<int> &postorder, size_t postorderi, size_t postorderj) {
        if (inorderi == inorderj || postorderi == postorderj) {
            return NULL;
        }
        int val = postorder[postorderj - 1];
        TreeNode *node = new TreeNode(val);
        size_t inorderMid = inorderi, postOrderMid = postorderi;
        while (inorderMid < inorderj) {
            if (inorder[inorderMid] == val) {
                break;
            }
            ++inorderMid;
            ++postOrderMid;
        }
        node->left = build(inorder, inorderi, inorderMid, postorder, postorderi, postOrderMid);
        node->right = build(inorder, inorderMid + 1, inorderj, postorder, postOrderMid, postorderj - 1);
        return node;
    }
};

// 
// Given inorder and postorder traversal of a tree, construct the binary tree. Note: You may assume that duplicates do not exist in the tree. Show Tags Tree Array Depth-first Search
// 
