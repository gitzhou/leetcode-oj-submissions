// 
// Generated by fetch-leetcode-submission project on GitHub.
// https://github.com/gitzhou/fetch-leetcode-submission
// Contact Me: aaron67[AT]aaron67.cc
// 
// Word Search
// https://leetcode.com/problems/word-search/
// 

class Solution {
public:
    bool exist(vector<vector<char> > &board, string word) {
        if (word.length() == 0) {
            return false;
        }
        vector<vector<bool> > footPrint(board.size());
        for (int m = 0; m < board.size(); ++m) {
            footPrint[m].resize(board[m].size());
            for (int n = 0; n < board[m].size(); ++n) {
                footPrint[m][n] = false;
            }
        }
        for (int i = 0; i < board.size(); ++i) {
            for (int j = 0; j < board[i].size(); ++j) {
                if (board[i][j] == word[0] && dfs(board, footPrint, word, i, j, 0)) {
                    return true;
                }
            }
        }
        return false;
    }
    
private:
    bool dfs(const vector<vector<char> > &board,
             vector<vector<bool> > &footPrint,
             const string &word,
             int i, int j, int depth) {
        if (depth == word.length() - 1) {
            return true;
        }
        footPrint[i][j] = true;
        // 左上右下四个方向
        int iTable[4] = {0, -1, 0, 1}, jTable[4] = {-1, 0, 1, 0};
        for (int k = 0; k < 4; ++k) {
            if (i + iTable[k] >= 0 && i + iTable[k] < board.size() &&
                j + jTable[k] >= 0 && j + jTable[k] < board[i].size() &&
                !footPrint[i + iTable[k]][j + jTable[k]] &&
                board[i + iTable[k]][j + jTable[k]] == word[depth + 1] &&
                dfs(board, footPrint, word, i + iTable[k], j + jTable[k], depth + 1)) {
                return true;
            }
        }
        footPrint[i][j] = false;
        return false;
    }
};

