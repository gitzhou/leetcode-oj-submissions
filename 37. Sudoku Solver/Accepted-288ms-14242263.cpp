// 
// Generated by fetch-leetcode-submission project on GitHub.
// https://github.com/gitzhou/fetch-leetcode-submission
// Contact Me: aaron67[AT]aaron67.cc
// 
// 37. Sudoku Solver
// https://leetcode.com/problems/sudoku-solver/
// 

class Solution {
public:
    void solveSudoku(vector<vector<char> > &board) {
        // 从一维角度搜索
        // i的范围为[0, GRID_TOTAL_ROW_COUNT_SIZE * GRID_TOTAL_ROW_COUNT_SIZE - 1)
        int i = 0;
        // 在搜索过程中，记录直至当前，0~i位置可以填哪些可选值
        vector<queue<char> > optionalVal(GRID_TOTAL_ROW_COUNT_SIZE * GRID_TOTAL_ROW_COUNT_SIZE);
        // 在搜索过程中，记录直至当前，哪些i位置的值，已被修改过
        stack<char> iset;
        // 搜索
        while (true) {
            // 将一维下标转换成二维下标
            int row = i / GRID_TOTAL_ROW_COUNT_SIZE, col = i % GRID_TOTAL_ROW_COUNT_SIZE;
            bool valid = true;
            if (i < GRID_TOTAL_ROW_COUNT_SIZE * GRID_TOTAL_ROW_COUNT_SIZE) {
                if (board[row][col] != '.') { // 当前位置的值是初始给定的，跳过本次
                    ++i;
                    continue;
                }
                // 计算当前位置的所有可选值
                if ((optionalVal[i] = updateOptionalVal(board, row, col)).size() == 0) {
                    valid = false;
                } else {
                    // 设置当前位置的值
                    board[row][col] = optionalVal[i].front();
                    optionalVal[i].pop();
                    // i位置的值修改过，更新
                    iset.push(i);
                }
            }
            if (valid && i >= GRID_TOTAL_ROW_COUNT_SIZE * GRID_TOTAL_ROW_COUNT_SIZE - 1) {
                // 找到一组解
                return;
            }
            if (valid && i < GRID_TOTAL_ROW_COUNT_SIZE * GRID_TOTAL_ROW_COUNT_SIZE - 1) {
                ++i; // 下一步
                continue;
            }
            // 回溯
            while (i >= GRID_TOTAL_ROW_COUNT_SIZE * GRID_TOTAL_ROW_COUNT_SIZE ||
                   (i >= 0 && optionalVal[i].size() == 0)) {
                if (iset.size() != 0 && iset.top() == i) { // 如果i位置的值被修改过
                    board[row][col] = '.';
                    iset.pop();
                }
                --i;
                row = i / GRID_TOTAL_ROW_COUNT_SIZE;
                col = i % GRID_TOTAL_ROW_COUNT_SIZE;
            }
            if (i == -1) {
                break; // 已试探全部可能
            } else {
                // 设置当前位置的值为下一个可选值
                board[row][col] = optionalVal[i].front();
                optionalVal[i].pop();
            }
        }
    }
    
private:
    // 计算表格row行col列位置，在当前情况下，可以填入的值
    // row从0开始计数
    // col从0开始计数
    queue<char> updateOptionalVal(const vector<vector<char> > &board, int row, int col) {
        queue<char> optionalVal;
        for (int i = 1; i <= GRID_TOTAL_ROW_COUNT_SIZE; ++i) {
            if (!valueIsShownInRow(board, i + '0', row) &&
                !valueIsShownInColumn(board, i + '0', col) &&
                !valueIsShownInOwn33Grid(board, i + '0', row, col)) {
                optionalVal.push(i + '0');
            }
        }
        return optionalVal;
    }
    
    // 判断表格row行，是否出现过值val
    // row从0开始计数
    bool valueIsShownInRow(const vector<vector<char> > &board, char val, int row) {
        for (int i = 0; i < GRID_TOTAL_ROW_COUNT_SIZE; ++i) {
            if (board[row][i] == val) {
                return true;
            }
        }
        return false;
    }
    
    // 判断表格col列，是否出现过值val
    // col从0开始计数
    bool valueIsShownInColumn(const vector<vector<char> > &board, char val, int col) {
        for (int i = 0; i < GRID_TOTAL_ROW_COUNT_SIZE; ++i) {
            if (board[i][col] == val) {
                return true;
            }
        }
        return false;
    }
    
    // 判断表格row行col列位置所在的宫，是否出现过值val
    // row从0开始计数
    // col从0开始计数
    bool valueIsShownInOwn33Grid(const vector<vector<char> > &board, char val, int row, int col) {
        for (int i = row / GRID_EACH_ROW_COUNT_SIZE * GRID_EACH_ROW_COUNT_SIZE;
             i < row / GRID_EACH_ROW_COUNT_SIZE * GRID_EACH_ROW_COUNT_SIZE + GRID_EACH_ROW_COUNT_SIZE;
             ++i) {
            for (int j = col / GRID_EACH_ROW_COUNT_SIZE * GRID_EACH_ROW_COUNT_SIZE;
                 j < col / GRID_EACH_ROW_COUNT_SIZE * GRID_EACH_ROW_COUNT_SIZE + GRID_EACH_ROW_COUNT_SIZE;
                 ++j) {
                if (board[i][j] == val) {
                    return true;
                }
            }
        }
        return false;
    }
    
public:
    static const int GRID_TOTAL_ROW_COUNT_SIZE = 9;
    static const int GRID_EACH_ROW_COUNT_SIZE = 3;
};

// 
// Write a program to solve a Sudoku puzzle by filling the empty cells. Empty cells are indicated by the character '.'. You may assume that there will be only one unique solution. A sudoku puzzle... ...and its solution numbers marked in red. Subscribe to see which companies asked this question Show Tags Backtracking Hash Table Show Similar Problems (E) Valid Sudoku
// 
